from __future__ import annotations

from sqlalchemy import (
    ForeignKey,
    ForeignKeyConstraint,
    UniqueConstraint,
    and_,
    exists,
    func,
    select,
)
from sqlalchemy.ext.associationproxy import AssociationProxy, association_proxy
from sqlalchemy.ext.hybrid import hybrid_method, hybrid_property
from sqlalchemy.orm import (
    DeclarativeBase,
    Mapped,
    Session,
    mapped_column,
    object_session,
    relationship,
    with_polymorphic,
)


class Base(DeclarativeBase):
    pass


class User(Base):
    __tablename__ = "user"

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str]

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name={self.name!r})"


class Report(Base):
    __tablename__ = "report"

    id: Mapped[int] = mapped_column(primary_key=True)
    species: Mapped[str]

    participants: Mapped[list[ReportParticipantAssociation]] = relationship(
        cascade="all, delete-orphan",
        # eager loading: load all participants together with the report
        # as info about them is needed in every report anyways
        lazy="selectin",
    )

    @property
    def roles(self):
        return [role for p in self.participants for role in p.roles]

    @hybrid_method
    def has_role(self, role: str | ReportParticipantRole):
        name = role.name if isinstance(role, ReportParticipantRole) else role
        return any(role.name == name for p in self.participants for role in p.roles)

    @has_role.expression
    def has_role(cls, role: str | ReportParticipantRole):
        name = role.name if isinstance(role, ReportParticipantRole) else role
        subq = (
            select(1)
            .select_from(ReportParticipantRoleAssociation)
            .join(
                ReportParticipantRole,
                ReportParticipantRoleAssociation.role_id == ReportParticipantRole.id,
            )
            .where(
                ReportParticipantRoleAssociation.report_id == cls.id,
                ReportParticipantRole.name == name,
            )
        )
        return exists(subq)

    @hybrid_property
    def participants_count(self):
        return len(self.participants)

    @participants_count.expression
    def participants_count(cls):
        return (
            select(func.count(ReportParticipantAssociation.id))
            .where(ReportParticipantAssociation.report_id == cls.id)
            .scalar_subquery()
        )

    @classmethod
    def get_with_number_of_participants(cls, session, n: int):
        stmt = (
            select(Report)
            .join(Report.participants)
            .group_by(Report.id)
            .having(func.count(Report.participants) == n)
        )
        return session.scalars(stmt).all()

    def __repr__(self) -> str:
        return (
            f"{self.__class__.__name__}(id={self.id!r}, "
            f"species={self.species!r}, "
            f"participants_count={self.participants_count!r})"
        )


class ReportParticipantAssociation(Base):
    # ! IMPORTANT:
    # ! - participants can only be mapped to one Report
    # ! - registered participants (users) use a "dummy" ID for each report
    # ! - unregistered participants are created on a per-report-basis
    # ! - a participant must have at least one role (separate table)
    __tablename__ = "report_participant_association"

    __table_args__ = (
        # ! (id, report_id) are used as composite FK in ReportParticipantRoleAssociation
        # to enforce the constraint "one report per participant"
        # for this a reliable reference to the "report_id" is needed
        # and creating a PK Composite key does not work reliably due to the
        # autogenerated "id" column
        UniqueConstraint(
            "id", "report_id", name="uq_report_participant_fake_composite_pk"
        ),
    )

    id: Mapped[int] = mapped_column(primary_key=True)
    report_id: Mapped[int] = mapped_column(ForeignKey(Report.id), nullable=False)

    has_account: Mapped[bool] = mapped_column(nullable=False)

    __mapper_args__ = {
        "polymorphic_on": has_account,
    }

    report: Mapped[Report] = relationship(
        back_populates="participants",
        lazy="selectin",
    )
    role_associations: Mapped[list[ReportParticipantRoleAssociation]] = relationship(
        cascade="all, delete-orphan",
        back_populates="participant",
        lazy="selectin",
    )
    # quick access to the concrete roles of a participant
    roles: AssociationProxy[list[ReportParticipantRole]] = association_proxy(
        "role_associations",
        "roles",
        creator=lambda roles: ReportParticipantRoleAssociation(roles=roles),
    )

    def __init__(self, roles, **kwargs):
        if not roles:
            raise ValueError("At least one role must be provided.")
        self.roles = roles
        super().__init__(**kwargs)

    def __repr__(self):
        return f"{self.__class__.__name__}(id={self.id!r}, report_id={self.report_id})"


class ReportParticipantRole(Base):
    __tablename__ = "report_participant_role"

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str]

    @classmethod
    def initial_data(cls):
        roles = ["creator", "reporter", "observer"]
        return roles

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(id={self.id}, name={self.name})"


class ReportParticipantRoleAssociation(Base):
    __tablename__ = "report_participant_role_association"
    __table_args__ = (
        # ! IMPORTANT:
        # ! this COMPOSITE FK guarantees enforcement of the constraint
        # ! "one report per participant", because the participant_id can only be
        # ! used in combination with the report_id it belongs to!
        ForeignKeyConstraint(
            ["report_id", "participant_id"],
            [ReportParticipantAssociation.report_id, ReportParticipantAssociation.id],
            name="fk_report_participant_role_report_participant",
        ),
        # ! Each report can have each role only once
        UniqueConstraint(
            "role_id", "report_id", name="uq_report_report_participant_role"
        ),
    )

    role_id: Mapped[int] = mapped_column(
        ForeignKey(ReportParticipantRole.id), primary_key=True
    )
    report_id: Mapped[int] = mapped_column(primary_key=True)  # Composite FK
    participant_id: Mapped[int] = mapped_column()  # Composite FK

    role: Mapped[ReportParticipantRole] = relationship(
        viewonly=True,
    )
    # Return list when queried from parent, otherwise it's role
    roles: Mapped[list[ReportParticipantRole]] = relationship(
        lazy="selectin",
    )
    participant: Mapped[ReportParticipantAssociation] = relationship()

    def __repr__(self) -> str:
        return (
            f"{self.__class__.__name__}(report_id={self.report_id!r}, "
            f"participant_id={self.participant_id!r}, "
            "role={self.role!r})"
        )


class ReportParticipantUnregistered(ReportParticipantAssociation):
    __tablename__ = "report_participant_unregistered"
    __mapper_args__ = {
        "polymorphic_identity": False,
        "polymorphic_load": "inline",
    }

    id: Mapped[int] = mapped_column(
        ForeignKey(ReportParticipantAssociation.id), primary_key=True
    )
    name: Mapped[str]

    def __repr__(self) -> str:
        parent_repr = super().__repr__()
        return f"{parent_repr[:-1]}, name={self.name!r})"


class ReportParticipantRegistered(ReportParticipantAssociation):
    __tablename__ = "report_participant_registered"
    __mapper_args__ = {
        "polymorphic_identity": True,
        "polymorphic_load": "inline",
    }

    id: Mapped[int] = mapped_column(
        ForeignKey(ReportParticipantAssociation.id), primary_key=True
    )
    user_id: Mapped[int] = mapped_column(ForeignKey(User.id), nullable=False)
    user: Mapped[User] = relationship(
        lazy="selectin",
    )

    @property
    def name(self):
        return self.user.name

    def __repr__(self) -> str:
        parent_repr = super().__repr__()
        return f"{parent_repr[:-1]}, user_id={self.user_id}, name={self.name!r})"

    @property
    def reports(self):
        return (
            object_session(self)
            .scalars(
                select(Report)
                .join(
                    with_polymorphic(
                        ReportParticipantAssociation, ReportParticipantRegistered
                    )
                )
                .where(ReportParticipantRegistered.user_id == self.user_id)
            )
            .all()
        )

    @classmethod
    def get_reports_for_user(cls, session: Session, user_id: int) -> list[Report]:
        return (
            session.query(Report)
            .join(cls, Report.id == cls.report_id)
            .filter(cls.user_id == user_id)
            .all()
        )

    def get_reports(self, session: Session) -> list[Report]:
        return self.__class__.get_reports_for_user(session, self.user_id)
